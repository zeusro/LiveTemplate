
## golang的坑

### 坑爹的内置API

- 获取字符串长度:
```go
len([]rune("文件夹,子文件夹,"))
```

- Split的坑
```go
	s := strings.Split("shit,", ",")
	fmt.Printf("len(s):%d\n", len(s))//2
	for _, v := range s {
		fmt.Printf("%s", v)
	}
```
strings.Split的字符串,如果用来分割的字符串恰好出现完整字符串的最后面,获得的数组长度会+1,这个数组的最后一个元素会是一个空白


- 时间转换函数
- 局部变量的坑

golang的字符串转日期函数非常不灵活,像下面这个转换的函数.如果字符串是"2017-3-27",用format1会出error

再者,**fmt.Print(err)**里的err是nil的,除非你是在else里面才能捕获

```go
func ToTime(str string) (time.Time, error) {
    var err error
    format1 := "2006-01-02 15:04:05"
    format2 := "2006-01-02"
    if loc, err := time.LoadLocation("Local"); err == nil {
        if t, err := time.ParseInLocation(format1, str, loc); err == nil {
            return t, nil
        }
        // else {
            fmt.Print(err)
        //}
        if date, err := time.ParseInLocation(format2, str, loc); err == nil {
            return date, nil
        }
    }
    return time.Now(), err
}
```

- 值类型不会溢出

```go
	var s int32 = 5120
	fmt.Print(s * 1024 * 1024)
	fmt.Print("\n")
	fmt.Print(int64(s) * 1024 * 1024)
	fmt.Print("\n")
	fmt.Print(math.MaxInt32)
	fmt.Print("\n")
	fmt.Print(math.MaxInt64)
    /*
1073741824
5368709120
2147483647
9223372036854775807
*/
```
以前用C#的时候,如果定义一个值类型变量,赋予它一个超出范围的值的话是会出异常的,然而到了golang,直接变成这个类型无符号最大值

- 切片/数组的坑

```go
	a := make([]int32, 2)
	fmt.Println(len(a))
	fmt.Println(a)
	b := make([]int32, 0, 4)
	fmt.Println(len(b))
	//b[0] = 0 //会报错
	fmt.Println(b)
	b = append(b, 666)
	fmt.Println(b)
/*
结果
2
[0 0]
0
[]
[666]
*/    
```

